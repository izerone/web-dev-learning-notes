# 数据结构

## 列表

列表是针对某种类型的值的有序集合。常用 LinkedList, ArrayList 。**列表是无界的**，和原生数组是需要事先指定规模的。

### 数据和列表的关系

#### 数组定义

定义数组时，在类型后面加上一堆方括号。同时是必须提供数组的大小，可以是显式的计数，也可以是自动推导出来的。

```java
    /**
     * 数组定义
     */
    @Test
    public void arrayDefinitions(){
        final int[] ints = new int[3];
        final boolean[] booleans = {false, true, true};
        final String[] strings = new String[]{"123", "234"};

        final Random r = new Random();
        final String[] randomArrayLength = new String[r.nextInt(100)];

    }

```

随机访问 : 通过索引值可以直接访问数组中的元素。

#### 数据复制

创建一个新的、更大的数组，把当前数组的所有元素都复制到新的数组中，然后将原来数组的引用重新复制给新的数组。

#### ArrayList 和 LinkedList

ArrayList  类是通过对 List 接口的一个实现，这个实现类内部是通过一个数组来存储列表要表示的数据。所以可以通过索引直接快速地访问某个指定元素，是直接访问到一个内存位置。

构建一个 ArrayList 时，可以选择设置底层数组的初始大小，如果不指定数值，默认大小为 10。如果在添加一个元素且底层数组满了，ArrayList 会进行数组扩展操作。这个过程可能占用大量的内存。因此，如果在构建 ArrayList 时，已经知道需要保存大量元素，**可以在构造函数中传入一个比较大的初始值，避免列表增长时发生太多耗时的数组重新分配的操作。**

数组大小的重新分配是**单向的**，删除元素时，数组不会缩小。

LinkedList 是 List 接口的另一种实现，它**不使用数组保存列表元素，而是内部使用对象保存元素，内部对象指向列表同类型的另一个对象。**

**经验法则 ** : 如果需要随机访问列表中的元素，特别是列表规模很大时，应该使用 ArrayList 。如果需要对列表进行大量插入和删除操作，特别是插入的元素在列表头部或中部时，则使用 LinkedList 更合理。LinkedList 不会遇到开销大的重分配操作，随着列表的收缩，内存使用量也会减少。

#### 题目 1 : Queue 和 Deque 是什么 ？

Queue ( 队列 ) 表示 ”先入先出“数据结构的 Java 接口。

- add 方法: 添加新的元素
- remove 方法: 删除最老的元素
- peek 方法: 返回但不删除最老的元素

Deque ( 双端队列 ) 是 Queue 的一个扩展，这种数据结构的两端都可以添加和删除元素。

## 树

树形数据结构中，元素可以有多个不同的后继。后继被称为子树。**二叉树 **( binary tree) 是一个常见的树形数据结构。**在一个二叉树中，每一个元素最多有两颗子树。**

二叉搜索树( binary search tree ) 是二叉树的一种实现。在二叉搜索树中，“小于等于”指定节点元素的元素被放在左子树中，“大于”指定节点元素的元素被放在右子树中。

二叉搜索树有一种特殊的实现成为 AVL 树。 AVL 强制规定 : 对于任何一个节点，其子树的深度差异最多为  1 。在每次插入或者删除一个节点后，算法检查树是否仍然平衡，如果不平衡，则对不满足 AVL 树的节点进行**旋转操作**。二叉树平衡后，搜索、插入和删除的复杂度为 O(log n).

二叉堆 ( binary heap ) 是二叉树的另一种应用，二叉堆是一种平衡二叉树，维持子节点“大于”其父节点的性质。

## 映射

映射 ( Map ) 也称作散列 ( hash )、关联数组 ( associative array ) 或字典，是一种键-值( key-value ) 存储数据结构。 其中的元素可以通过键来查询，得到是键关联的值。

映射数据结构有一个性质 :** 一个键在映射中只能出现一次，如果插入同一个键，那么这个键原来关联的值就会被覆盖。 **

### HashMap

HashMap 类是 Java 的散列表实现。键值对在表中存放的位置有键实例的具体值决定。 Object 类中定义了 hashCode 方法，该方法返回一个 int 值，这个值决定了键值对在表中存储的具体位置。**两个相等的实例必须返回同一个 hashCode 值，两个相等的 hashCode 值并不意味着两个对象是相等的。
**

### TreeMap

TreeMap 是通过二叉树数据结构来实现 Map 接口。树中的每一个节点都是键值对。

TreeMap 和 HashMap 的主要区别是，在遍历整个集合时， TreeMap 的键的顺序是不变的。因为集合时按照顺序存储的，而 HashMap 键的存储位置是由对象的 hashCode 决定的。

#### LinkedHashMap

LinkedHashMap 是 Map 的一个特殊实现，实现的工作方式和 HashMap 完全相同。特性是键的遍历顺序和插入顺序是相同的。

#### ConcurrentHashMap

ConcurrentHashMap 是线程安全的，当有线程在向映射写入值时，其他线程可以同时从映射中读出值。在写入值时，只有特定的行会被上锁，映射数据结构中的其他部分都可以读。

## 集合

集合( set ) 是一个无序的非重复对象容器。

- HashSet
- TreeSet
- LinkedHashSet

Collections 类有一个 SetFromMap 方法，可以把 Map 转换为 Set , Set 具有 Map 的一切属性。

> 要对数据结构方面的问题做好准备。面试官希望了解你对数据结构的不同实现以及选择不同的实现对应用程序性能的影响的理解。同时还需要解释不同数据结构的使用场景。
